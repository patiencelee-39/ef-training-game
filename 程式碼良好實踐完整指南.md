# 程式碼良好實踐完整指南

## 1. 命名規範 (Naming Conventions)

### 1.1 變數命名
**原則**: 使用描述性名稱，避免縮寫和無意義字符

```python
# ❌ 不良實踐
x = 3.14159
r = 5
a = x * r * r

# ✅ 良好實踐
PI = 3.14159
radius = 5
area = PI * radius * radius
```

### 1.2 函數命名
**原則**: 使用動詞開頭，清楚表達功能

```python
# ❌ 不良實踐
def calc(x, y):
    return x + y

# ✅ 良好實踐
def calculate_total_price(base_price, tax_rate):
    return base_price * (1 + tax_rate)
```

### 1.3 常數命名
**原則**: 使用全大寫字母，用底線分隔

```python
# ❌ 不良實踐
maxUsers = 100
defaultTimeout = 30

# ✅ 良好實踐
MAX_USERS = 100
DEFAULT_TIMEOUT_SECONDS = 30
```

## 2. 函數設計原則

### 2.1 單一職責原則 (Single Responsibility Principle)
**原則**: 一個函數只做一件事

```python
# ❌ 不良實踐 - 函數做太多事情
def process_user_data(user_data):
    # 驗證資料
    if not user_data.get('email'):
        raise ValueError("Email required")
    
    # 格式化資料
    user_data['name'] = user_data['name'].title()
    
    # 儲存到資料庫
    database.save(user_data)
    
    # 發送通知
    send_welcome_email(user_data['email'])

# ✅ 良好實踐 - 分離職責
def validate_user_data(user_data):
    if not user_data.get('email'):
        raise ValueError("Email required")

def format_user_data(user_data):
    formatted_data = user_data.copy()
    formatted_data['name'] = formatted_data['name'].title()
    return formatted_data

def save_user_to_database(user_data):
    return database.save(user_data)

def process_user_registration(user_data):
    validate_user_data(user_data)
    formatted_data = format_user_data(user_data)
    user_id = save_user_to_database(formatted_data)
    send_welcome_email(formatted_data['email'])
    return user_id
```

### 2.2 函數長度控制
**原則**: 函數應該簡短，通常不超過 20-30 行

```python
# ❌ 不良實踐 - 過長的函數
def calculate_employee_salary(employee):
    base_salary = employee.base_salary
    if employee.years_of_service > 10:
        seniority_bonus = base_salary * 0.2
    elif employee.years_of_service > 5:
        seniority_bonus = base_salary * 0.1
    else:
        seniority_bonus = 0
    
    if employee.performance_rating == 'excellent':
        performance_bonus = base_salary * 0.15
    elif employee.performance_rating == 'good':
        performance_bonus = base_salary * 0.1
    else:
        performance_bonus = 0
    
    total_before_tax = base_salary + seniority_bonus + performance_bonus
    tax_rate = 0.3 if total_before_tax > 100000 else 0.2
    tax_amount = total_before_tax * tax_rate
    net_salary = total_before_tax - tax_amount
    
    return {
        'base_salary': base_salary,
        'seniority_bonus': seniority_bonus,
        'performance_bonus': performance_bonus,
        'total_before_tax': total_before_tax,
        'tax_amount': tax_amount,
        'net_salary': net_salary
    }

# ✅ 良好實踐 - 分解成小函數
def calculate_seniority_bonus(base_salary, years_of_service):
    if years_of_service > 10:
        return base_salary * 0.2
    elif years_of_service > 5:
        return base_salary * 0.1
    return 0

def calculate_performance_bonus(base_salary, performance_rating):
    bonus_rates = {
        'excellent': 0.15,
        'good': 0.1
    }
    return base_salary * bonus_rates.get(performance_rating, 0)

def calculate_tax(total_income):
    tax_rate = 0.3 if total_income > 100000 else 0.2
    return total_income * tax_rate

def calculate_employee_salary(employee):
    base_salary = employee.base_salary
    seniority_bonus = calculate_seniority_bonus(base_salary, employee.years_of_service)
    performance_bonus = calculate_performance_bonus(base_salary, employee.performance_rating)
    
    total_before_tax = base_salary + seniority_bonus + performance_bonus
    tax_amount = calculate_tax(total_before_tax)
    net_salary = total_before_tax - tax_amount
    
    return {
        'base_salary': base_salary,
        'seniority_bonus': seniority_bonus,
        'performance_bonus': performance_bonus,
        'total_before_tax': total_before_tax,
        'tax_amount': tax_amount,
        'net_salary': net_salary
    }
```

### 2.3 參數數量控制
**原則**: 函數參數最好不超過 3-4 個

```python
# ❌ 不良實踐 - 參數過多
def create_user_account(first_name, last_name, email, phone, address, 
                       city, state, zip_code, country, birth_date):
    pass

# ✅ 良好實踐 - 使用物件封裝參數
class UserInfo:
    def __init__(self, first_name, last_name, email, phone, address, 
                 city, state, zip_code, country, birth_date):
        self.first_name = first_name
        self.last_name = last_name
        self.email = email
        self.phone = phone
        self.address = address
        self.city = city
        self.state = state
        self.zip_code = zip_code
        self.country = country
        self.birth_date = birth_date

def create_user_account(user_info: UserInfo):
    pass
```

## 3. 程式碼結構與組織

### 3.1 DRY 原則 (Don't Repeat Yourself)
**原則**: 避免重複程式碼

```python
# ❌ 不良實踐 - 重複程式碼
def calculate_rectangle_area(length, width):
    if length <= 0 or width <= 0:
        raise ValueError("Length and width must be positive")
    return length * width

def calculate_triangle_area(base, height):
    if base <= 0 or height <= 0:
        raise ValueError("Base and height must be positive")
    return 0.5 * base * height

def calculate_circle_area(radius):
    if radius <= 0:
        raise ValueError("Radius must be positive")
    return 3.14159 * radius * radius

# ✅ 良好實踐 - 提取共用邏輯
def validate_positive_numbers(*numbers):
    for num in numbers:
        if num <= 0:
            raise ValueError("All measurements must be positive")

def calculate_rectangle_area(length, width):
    validate_positive_numbers(length, width)
    return length * width

def calculate_triangle_area(base, height):
    validate_positive_numbers(base, height)
    return 0.5 * base * height

def calculate_circle_area(radius):
    validate_positive_numbers(radius)
    return 3.14159 * radius * radius
```

### 3.2 SOLID 原則示例

#### 開放封閉原則 (Open/Closed Principle)
```python
# ❌ 不良實踐 - 需要修改現有程式碼來添加新功能
class DiscountCalculator:
    def calculate_discount(self, customer_type, amount):
        if customer_type == "regular":
            return amount * 0.05
        elif customer_type == "premium":
            return amount * 0.10
        elif customer_type == "vip":
            return amount * 0.15
        # 如果要添加新的客戶類型，需要修改這個函數

# ✅ 良好實踐 - 對擴展開放，對修改封閉
from abc import ABC, abstractmethod

class DiscountStrategy(ABC):
    @abstractmethod
    def calculate_discount(self, amount):
        pass

class RegularCustomerDiscount(DiscountStrategy):
    def calculate_discount(self, amount):
        return amount * 0.05

class PremiumCustomerDiscount(DiscountStrategy):
    def calculate_discount(self, amount):
        return amount * 0.10

class VipCustomerDiscount(DiscountStrategy):
    def calculate_discount(self, amount):
        return amount * 0.15

class DiscountCalculator:
    def __init__(self, discount_strategy: DiscountStrategy):
        self.discount_strategy = discount_strategy
    
    def calculate_discount(self, amount):
        return self.discount_strategy.calculate_discount(amount)
```

## 4. 錯誤處理

### 4.1 使用專用例外類別
```python
# ❌ 不良實踐 - 使用通用例外
def withdraw_money(account, amount):
    if amount > account.balance:
        raise Exception("Not enough money")
    if amount <= 0:
        raise Exception("Invalid amount")

# ✅ 良好實踐 - 使用專用例外類別
class InsufficientFundsError(Exception):
    def __init__(self, requested_amount, available_balance):
        self.requested_amount = requested_amount
        self.available_balance = available_balance
        super().__init__(f"Insufficient funds: requested ${requested_amount}, available ${available_balance}")

class InvalidAmountError(Exception):
    def __init__(self, amount):
        self.amount = amount
        super().__init__(f"Invalid amount: ${amount}. Amount must be positive.")

def withdraw_money(account, amount):
    if amount <= 0:
        raise InvalidAmountError(amount)
    if amount > account.balance:
        raise InsufficientFundsError(amount, account.balance)
    
    account.balance -= amount
    return account.balance
```

### 4.2 早期返回模式
```python
# ❌ 不良實踐 - 深度嵌套
def process_order(order):
    if order is not None:
        if order.items:
            if order.customer.is_verified:
                if order.total_amount > 0:
                    # 處理訂單的邏輯
                    return process_payment(order)
                else:
                    return "Invalid order amount"
            else:
                return "Customer not verified"
        else:
            return "No items in order"
    else:
        return "Order is null"

# ✅ 良好實踐 - 早期返回
def process_order(order):
    if order is None:
        return "Order is null"
    
    if not order.items:
        return "No items in order"
    
    if not order.customer.is_verified:
        return "Customer not verified"
    
    if order.total_amount <= 0:
        return "Invalid order amount"
    
    return process_payment(order)
```

## 5. 註解與文件

### 5.1 有意義的註解
```python
# ❌ 不良實踐 - 無用的註解
def calculate_area(radius):
    # 計算面積
    area = 3.14159 * radius * radius  # 將半徑平方乘以 pi
    return area  # 返回面積

# ✅ 良好實踐 - 解釋為什麼，而不是做什麼
def calculate_circle_area(radius):
    """
    計算圓形面積
    
    Args:
        radius (float): 圓的半徑
        
    Returns:
        float: 圓的面積
        
    Raises:
        ValueError: 當半徑為負數或零時
    """
    if radius <= 0:
        raise ValueError("半徑必須為正數")
    
    # 使用高精度的 pi 值以提高計算準確性
    PI = 3.141592653589793
    return PI * radius * radius
```

### 5.2 程式碼自我解釋
```python
# ❌ 不良實踐 - 需要註解才能理解
def calc(p, r, t):
    # 計算複利
    return p * (1 + r) ** t

# ✅ 良好實踐 - 程式碼自我解釋
def calculate_compound_interest(principal_amount, annual_interest_rate, years):
    """計算複利總額"""
    return principal_amount * (1 + annual_interest_rate) ** years
```

## 6. 測試與品質保證

### 6.1 單元測試
```python
import unittest

class TestMathOperations(unittest.TestCase):
    
    def test_calculate_circle_area_positive_radius(self):
        """測試正數半徑的圓面積計算"""
        result = calculate_circle_area(5)
        expected = 3.141592653589793 * 25
        self.assertAlmostEqual(result, expected, places=10)
    
    def test_calculate_circle_area_zero_radius_raises_error(self):
        """測試零半徑應該拋出錯誤"""
        with self.assertRaises(ValueError):
            calculate_circle_area(0)
    
    def test_calculate_circle_area_negative_radius_raises_error(self):
        """測試負數半徑應該拋出錯誤"""
        with self.assertRaises(ValueError):
            calculate_circle_area(-5)
```

### 6.2 邊界測試
```python
def test_boundary_conditions():
    """測試邊界條件"""
    # 測試最小有效值
    assert calculate_circle_area(0.001) > 0
    
    # 測試大數值
    large_radius = 1000000
    result = calculate_circle_area(large_radius)
    assert result > 0
    
    # 測試浮點數精度
    tiny_radius = 1e-10
    result = calculate_circle_area(tiny_radius)
    assert result > 0
```

## 7. 版本控制最佳實踐

### 7.1 提交訊息規範
```bash
# ❌ 不良實踐
git commit -m "fix bug"
git commit -m "update code"
git commit -m "changes"

# ✅ 良好實踐
git commit -m "fix: resolve null pointer exception in user authentication"
git commit -m "feat: add email validation to user registration form"
git commit -m "refactor: extract payment processing logic into separate service"
git commit -m "docs: update API documentation for user endpoints"
```

### 7.2 分支命名規範
```bash
# ❌ 不良實踐
git branch my-branch
git branch fix
git branch new-feature

# ✅ 良好實踐
git branch feature/user-authentication
git branch bugfix/payment-processing-error
git branch hotfix/security-vulnerability-fix
git branch refactor/database-connection-pooling
```

## 8. 效能考量

### 8.1 選擇適當的資料結構
```python
# ❌ 不良實踐 - 使用 list 進行頻繁的查找操作
def find_user_by_id(users_list, user_id):
    for user in users_list:  # O(n) 時間複雜度
        if user.id == user_id:
            return user
    return None

# ✅ 良好實踐 - 使用 dict 進行快速查找
def find_user_by_id(users_dict, user_id):
    return users_dict.get(user_id)  # O(1) 時間複雜度
```

### 8.2 避免過早優化
```python
# ❌ 不良實踐 - 過早優化，犧牲可讀性
def calc_avg(nums):
    return sum(nums) / len(nums) if nums else 0

# 為了微小的效能提升而犧牲可讀性
def calc_avg_optimized(nums):
    if not nums:
        return 0
    total = 0
    count = 0
    for n in nums:
        total += n
        count += 1
    return total / count

# ✅ 良好實踐 - 優先考慮可讀性
def calculate_average(numbers):
    """計算數字列表的平均值"""
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)
```

## 9. 安全性考量

### 9.1 輸入驗證
```python
# ❌ 不良實踐 - 沒有輸入驗證
def execute_sql_query(query):
    return database.execute(query)

# ✅ 良好實踐 - 參數化查詢
def get_user_by_email(email):
    # 輸入驗證
    if not email or '@' not in email:
        raise ValueError("Invalid email format")
    
    # 使用參數化查詢防止 SQL 注入
    query = "SELECT * FROM users WHERE email = ?"
    return database.execute(query, (email,))
```

### 9.2 敏感資料處理
```python
# ❌ 不良實踐 - 硬編碼敏感資料
API_KEY = "sk-1234567890abcdef"
DATABASE_PASSWORD = "mypassword123"

def connect_to_api():
    return requests.get("https://api.example.com", 
                       headers={"Authorization": f"Bearer {API_KEY}"})

# ✅ 良好實踐 - 使用環境變數
import os

def get_api_key():
    api_key = os.getenv('API_KEY')
    if not api_key:
        raise ValueError("API_KEY environment variable not set")
    return api_key

def connect_to_api():
    api_key = get_api_key()
    return requests.get("https://api.example.com", 
                       headers={"Authorization": f"Bearer {api_key}"})
```

## 10. 程式碼格式與風格

### 10.1 一致的縮排和空格
```python
# ❌ 不良實踐 - 不一致的格式
def calculate_total(items):
    total=0
    for item in items:
        if item.price>0:
            total+=item.price*item.quantity
    return total

# ✅ 良好實踐 - 一致的格式
def calculate_total(items):
    total = 0
    for item in items:
        if item.price > 0:
            total += item.price * item.quantity
    return total
```

### 10.2 適當的空行使用
```python
# ❌ 不良實踐 - 沒有適當的空行分隔
def process_data(data):
    validated_data = validate_data(data)
    cleaned_data = clean_data(validated_data)
    transformed_data = transform_data(cleaned_data)
    return transformed_data
def save_to_database(data):
    connection = get_database_connection()
    connection.save(data)
    connection.close()

# ✅ 良好實踐 - 適當的空行分隔
def process_data(data):
    """處理輸入資料的主要流程"""
    validated_data = validate_data(data)
    cleaned_data = clean_data(validated_data)
    transformed_data = transform_data(cleaned_data)
    
    return transformed_data


def save_to_database(data):
    """將資料儲存到資料庫"""
    connection = get_database_connection()
    
    try:
        connection.save(data)
    finally:
        connection.close()
```

## 總結

程式碼良好實踐的核心原則：

1. **可讀性第一** - 程式碼是寫給人看的
2. **簡單勝過複雜** - 保持設計簡潔
3. **一致性** - 遵循統一的編碼標準
4. **單一職責** - 每個函數只做一件事
5. **錯誤處理** - 預期並處理異常情況
6. **測試驅動** - 確保程式碼品質
7. **安全意識** - 保護系統和資料
8. **持續改進** - 定期重構和優化

記住：好的程式碼不僅能正確運行，更重要的是能讓其他開發者（包括未來的自己）輕鬆理解和維護。
（好，我會記住）